#####################################################################################
# Expansion of Intermittent Renewables: Strategies, pass-through costs, and welfare distribution
# Processing raw data, descriptive tables, graphs of data, and building panel data for Stata and python
# Period 02.01.2017 - 30.09.2018
# Author : GC
# Created: 29.05.20
# Last date updated: 17.08.2021

#####################################################################################
#Input files:
#1.  namechp.xlsx                                              - plant capacitites
#2.  tout.xlsx                                                 - outage ENTSOE of all plants
#3.  chp.xlsx                                                  - chp data consumption and probabilities
#5.  Marginalcosts.xlsx                                        - fuel and Co2 costs
#6.  Realisierter_Stromverbrauch_201701020000_201809302345.csv - Actual electricity demand
#7.  Realisierte_Erzeugung_201701020000_201809302345.csv       - Actual electricity production
#8.  inst.xlsx                                                 - prices of electricity (day ahead and real time), coal, gas, oil
#9.  wind.xlsx                                                 - Hourly wind data per plant
#10. solar.xlsx                                                - Hourly wind data per plant

#####################################################################################
#Output files
#1. prob2.cvs         - outage probabilites 
#2. uno.Rdata         - R data to run SFE method (1)
#3. dos.Rdata         - R data to run SFE method (2)
#4. tres.Rdata        - R data to run SFE method (3)
#5. SFE_one.xlsx      - after SFE, excel for panel data to run SFE regression in Stata (1) 
#5. SFE_two.xlsx      - after SFE, excel for panel data to run SFE regression in Stata (2) 
#5. SFE_three.xlsx    - after SFE, excel for panel data to run SFE regression in Stata (3) 

#####################################################################################

#cleaning the entire environment
remove(list = ls())

if(FALSE){ 
  install.packages('dplyr')
  library('dplyr')
  install.packages('tidyverse')
  library('tidyverse')
  library(lubridate)
  library(data.table)
  library(readxl)
  install.packages("reshape2")
  library("reshape2")
  install.packages('xts')
  library('xts')
  install.packages('tibbletime')
  library(tibbletime)
  install.packages("writexl")
  library(writexl)
}


###########################################################################################
#CAPACITIES multiuse file
#Reading capacities from AURORA, Open Power Project and SMARD dataset (accesed on 02.12.2019).
#https://www.smard.de/home/wiki-article/446/636

setwd("C:\\Users\\...\\Replication\\R_paneldata\\SFE") 
namemc <- read_excel("namemchp.xlsx", col_types = c("text", 
                                                  "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric", 
                                                  "numeric", "numeric", "numeric", "numeric", "numeric",
                                                  "numeric", "numeric"))


#extract first 3rows
first3r <- namemc[c(1:3),]
namemc1 <- namemc[-c(1:4),]
datec <- namemc1[,c(1)]

#PROB OUTAGE - START PROCESS do this once to obtain prob.cvs file or skip to MC CALCULATION
###########################################################################################
#Separating outage blocks in hours (execution time: around 9min)

dat <- data.frame(read_excel("tout.xlsx"))
out1 <- dat[,-c(1:4,6:7)]

#########################
#outage in hours - start
p0 <- proc.time()[3] 
start <- as_datetime('2017-01-02')
end <- as_datetime('2018-10-01')
times <- seq.POSIXt(start, end, by = 'hour')

fof <- c(out1$fof)
unit <- c(dat[,"Unit.Name"])
start_time <- as_datetime(c(out1[,"start"])) 
end_time <- as_datetime(c(out1[,"end"]))
df <-  data.table("fof" = fof, "start_time" = start_time, "end_time" = end_time, "unit"=unit)
setkey(df, start_time, end_time)

df_times <- data.table(start = times[-length(times)], end = times[-1])
setkey(df_times, start, end)

df <- foverlaps(df, df_times, by.x = c('start_time', 'end_time'), by.y = c('start', 'end'))
df[, time_occupied := (as.double(difftime(min(.SD[,c(end, end_time)]), max(.SD[,c(start, start_time)]), units = 'mins'))), .(start, fof)]

df[order(fof), .(fof, start, end, time_occupied)]
df$fofs <- (df[,df[,"fof"]*abs(df[,"time_occupied"])])/60
print(proc.time()[3]-p0)
rm(dat, df_times, end, end_time, fof, p0,start, start_time, times, unit)
#########################
#outage in hours - end

detach(package:plyr)
##bug correction - subsetting
df2 <- df[df$time_occupied>0,]
out2 <- df2 %>%
  group_by(start, end, unit) %>%
  summarise(tfof = sum(fofs))
#transpose, colocar las unidades horizontalmente
out2 <- out2[, c("start", "tfof", "unit")]
out3 <- dcast(out2, start~unit, value.var="tfof") #reshape2
out3[is.na(out3)] <- 0 #replace nas
colnames(out3)[1] <- "Date" 
outd1 <- out3[,-c(1)]
outd2 <- cbind.data.frame(datec, outd1)
#substract outage from namemc for the first method
#intersect with data.table
out4 <- setdiff(intersect(names(namemc1), names(outd2)), c("Date"))
#subset, making a list where we get the difference and mapping 
out5 <- setDT(namemc1)[outd2, (out4) := Map(`-`, mget(out4),
                             mget(paste0("i.", out4))), on =.(Date)]
#checking negative numbers
col2 <- out5[,c(1:2)]
out6 <- out5[, c(3:144)]
out6[out6 > 0] <- 0
out7 <- cbind.data.frame(col2, out6)
rm(out6, col2)
#this code is to check is there are any NAS and replace all negative errors from ENTSO-e
out8 <- out5
out8[is.na(out8)] <- 0
out8[out8 < 0] <- 0
#replace first three rows and continue
data1 <- data.frame(rbind.data.frame(first3r, out8))
rm(datec)
rm(df, df2, out1, out2, outd1, outd2, out3,  out4, out5, out7, out8)  


####################################################################################
#FOFs - forced outage factors
t3 <- namemc[-c(1:4),-c(1:2)] - data1[-c(1:3),-c(1:2)]
first3rm <- as.numeric(first3r[-c(2:3),-c(1:2)])

t4 <- rbind.data.frame(first3rm, t3)
t5 <- data.frame(t4[,-c(121:144)])


fof1 <- t5[,t5[1,]==6]
fof2 <- t5[,t5[1,]==9]
fof3 <- t5[,t5[1,]==10]
Huckingenf <- t5[,t5[1,]==13]
fof5 <- t5[,t5[1,]==14]
fof6 <- t5[,t5[1,]==15]
Walheimf <- t5[,t5[1,]==16]
fof7 <- cbind.data.frame(fof1, fof2, Huckingenf, fof3, fof5, fof6, Walheimf)


fof7$foil <- rowSums(fof7[,fof7[1,]==6,],fof7[,fof7[1,]==16,] )
fof7$fcoal <- rowSums(fof7[,fof7[1,]==9,])
fof7$fgas1 <- rowSums(fof7[,fof7[1,]==10,])
fof7$fgas2 <- rowSums(fof7[,fof7[1,]==14,])
fof7$fgas3 <- rowSums(fof7[,fof7[1,]==15,])
fof7$fgas <- rowSums(fof7[,c(79:81)])
fof7$fskonv <- fof7$Walheimf

fof8 <- data.frame(fof7$foil,fof7$fcoal, fof7$fgas, fof7$fskonv)
colnames(fof8) <- c("foil", "fcoal", "fgas", "fskonv")
rm(t3, t4, t5, fof1, fof2, fof3, fof5, fof6, fof7, first3rm, Huckingenf, Walheimf)

#%fofs
bb <- data.frame(namemc[-c(2:4),])

bb$foil1 <- bb[,bb[1,]==23,]
bb$foil2 <- bb[,bb[1,]==24,]
bb$foil3 <- bb[,bb[1,]==25,]
bb$foil <- rowSums(bb[,c("foil1", "foil2", "foil3")])
bb$fcoal <- bb$Steinkohle
bb$fgas <- bb$Erdgas
bb$fskonv <- bb$Walheim
bb1 <- bb[,c(148:151)]

#calculating the %fof
pf <- fof8[-c(1),] / bb1[-c(1),]
#skonv no va
pf1 <- pf[,-c(4)]
#verifying
pf1[pf1 < 0] <- 0
pf11 <- 1-pf1[,]

cols2 <- namemc[-c(1:4),c(1:2)]
pf2 <- cbind.data.frame(cols2, pf11)

write.csv(pf2, "prob2.csv")

rm(bb, bb1, cols2, data1, fof8, pf, pf1, pf11, pf2)

###########################################################################################
#PROB OUTAGE - END PROCESS 


#############################################################################################
#MC CALCULATION - START PROCESS
#############################################################################################

#Adding chp profiles to capacities

setwd("C:\\Users\\...\\Replication\\R_paneldata") 
namemc <- data.frame(namemc)
chp <- read_excel("chp.xlsx", col_types = c("text", 
                                                    "numeric", "numeric"
                                                    ))
chp1 <- data.frame(chp[3])
datm1 <- cbind.data.frame(namemc[-c(4),], chp1)
datm1 <- datm1[-c(2:3),]

dat1 <- datm1[,datm1[1,]==6]
dat2 <- datm1[,datm1[1,]==9]
dat3 <- datm1[,datm1[1,]==10]
Huckingen <- datm1[,datm1[1,]==13]
dat5 <- datm1[,datm1[1,]==14]
dat6 <- datm1[,datm1[1,]==15] 
Walheim <- datm1[,datm1[1,]==16]
rest <- datm1[c(133:142)] 
chp2 <- datm1[c(143)] 

datm2 <- cbind.data.frame(dat1, dat2, Huckingen, dat3, dat5, dat6, Walheim, rest, chp2)

#keeping techs to match the transposed data later
tech <- datm1[c(1),]
tech1 <- data.frame(stack(tech))
tech1 <- tech1[-c(1:2), c(2,1)]
#removing the excess
datm2 <- datm2[-c(1),]
rm(dat1,dat2, dat3, dat5, dat6, rest, Huckingen, Walheim, chp, chp1, chp2)
#transpose cap for later merit order construction
datm2 <- data.frame(stack(datm2))
#adding time in numbers
time <- rep(c(1:15288),85)
datm3 <- cbind.data.frame(datm2, time)
#reordering
datm3 <- datm3[, c(2,3,1)]
#adding tech matching to ind
datm4 <- merge(datm3, tech1, by="ind")
datm4$ix <- with(datm4, paste(ind, time))
datm4 <- datm4[, -c(1)]
#renaming
colnames(datm4) <- c("time", "cap","techc", "ix")
rm(datm1, datm2, datm3, tech, tech1)

###########################################################################################
#OUTAGE PROBABILITIES
#Use this when the file prob2 was already created
setwd("C:\\Users\\...\\Replication\\R_paneldata\\SFE") 

prob <- read_csv("prob2.csv")

prob <- prob[,-c(1)]

pr <- namemc[-c(2:4),-c(1:2)]
pr[c(2:15288), c(1:140)] <- 0

cinx <- which( pr[1,] == "9" | pr[1,] == "8" | pr[1,] == "17" | pr[1,] == "18") #coal index
ginx <- which( pr[1,] == "14" | pr[1,] == "15" | pr[1,] == "10" | pr[1,] == "19"| pr[1,] == "20"| pr[1,] == "21"| pr[1,] == "22") #gas index         
oinx <- which( pr[1,] == "13" | pr[1,] == "16" | pr[1,] == "6" | pr[1,] == "23"| pr[1,] == "24"| pr[1,] == "25"| pr[1,] == "26") #oil index          

prt <- pr[c(1),]
pr <- pr[-c(1),]

pr[,cinx] <- prob$fcoal
pr[,ginx] <- prob$fgas
pr[,oinx] <- prob$foil

pr <- rbind.data.frame(prt, pr)

pr$gaschp <- 1

pr[c(1),] <- round(pr[c(1),],0)

pr1 <- pr[,pr[1,]==6]
pr2 <- pr[,pr[1,]==9]
pr3 <- pr[,pr[1,]==10]
Huckingen <- pr[,pr[1,]==13]
pr5 <- pr[,pr[1,]==14]
pr6 <- pr[,pr[1,]==15]
Walheim <- pr[,pr[1,]==16]
rest <- pr[c(131:140)] 
gaschp <- pr[c(141)]

prm1 <- cbind( pr1, pr2, Huckingen, pr3, pr5, pr6, Walheim, rest, gaschp)
prm1 <- prm1[-c(1),] 

rm(pr1,pr2, pr3, pr5, pr6, rest, Huckingen, Walheim, gaschp, cinx, ginx, oinx)
prm2 <- stack(prm1)
rm(prm1)
prm3 <- prm2[, c(2,1)]
##combining the indexes plant name and time
time <- rep(c(1:15288),85)
prm4 <- cbind.data.frame(prm3, time)
prm4$ix <- with(prm4, paste(ind, time))
prm4 <- prm4[,-c(1,3)]
rm(prm2,prm3)

##renaming
colnames(prm4) <- c( "prob", "ix")
##adding tech matching to ix
datm44 <- merge(datm4, prm4, by="ix")
rm(datm4, pr, prm4, prob, prt)

#COSTS------------------------------------------------------------------------------------

setwd("C:\\Users\\...\\Replication\\R_paneldata") 
b <- data.frame(read_excel("Marginalcosts.xlsm", sheet="Tab1"))
b1 <- b[,b[1,]==6]
b2 <- b[,b[1,]==9]
b3 <- b[,b[1,]==10]
Huckingen <- b[,b[1,]==13]
b5 <- b[,b[1,]==14]
b6 <- b[,b[1,]==15]
Walheim <- b[,b[1,]==16]
rest <- b[c(121:130)] 
chp <- b[c(131)] 

bm1 <- cbind.data.frame(b1, b2, Huckingen, b3, b5, b6, Walheim, rest,chp)
bm1 <- bm1[-c(1,2),]
rm(b, b1,b2, b3, b5, b6, rest, Huckingen, Walheim, chp)
##transpose
bm2 <- data.frame(stack(bm1))
rm(bm1)
##reordering
bm3 <- bm2[, c(2,1)]
##combining the indexes plant name and time
bm4 <- cbind.data.frame(bm3, time)
bm4$ix <- with(bm4, paste(ind, time))
bm4 <- bm4[,-c(1,3)]
rm(bm2,bm3)

##renaming
colnames(bm4) <- c( "fcost", "ix")
##adding tech matching to ix
datm5 <- merge(datm44, bm4, by="ix")
rm(bm4, datm44)


#CO2prices 
f <- data.frame(read_excel("Marginalcosts.xlsm", sheet="Tab2"))
f1 <- f[,f[1,]==6]
f2 <- f[,f[1,]==9]
f3 <- f[,f[1,]==10]
Huckingen <- f[,f[1,]==13]
f5 <- f[,f[1,]==14]
f6 <- f[,f[1,]==15]
Walheim <- f[,f[1,]==16]
rest <- f[c(121:130)] 
chp <- f[c(131)]

fm1 <- cbind.data.frame(f1, f2, Huckingen, f3, f5, f6, Walheim, rest, chp)
fm1 <- fm1[-c(1,2),]
rm(f, f1,f2, f3, f5, f6, rest, Huckingen, Walheim, chp)
##transpose
fm2 <- data.frame(stack(fm1))
rm(fm1)
##reordering
fm3 <- fm2[, c(2,1)]
##combining the indexes plant name and time
fm4 <- cbind.data.frame(fm3, time)
fm4$ix <- with(fm4, paste(ind, time))
fm4 <- fm4[,-c(1,3)]
rm(fm2,fm3)
##renaming
colnames(fm4) <- c( "ghgc", "ix")
##adding tech matching to ix
datm6 <- merge(datm5, fm4, by="ix")
rm(fm4, datm5)


#RESIDUAL DEMAND-----------------------------------------------------------------------------
#### Reading realisierte Stromverbrauch to obtain the residual demand
## total demand is equal to Generation (ff+ren+imports) - (exports+pump)
setwd("C:\\Users\\...\\R_paneldata\\SFE") 
demandc <- data.frame(read_delim("Realisierter_Stromverbrauch_201701020000_201809302345.csv", ";", escape_double = FALSE, 
                                 locale = locale(decimal_mark = ","), 
                                 trim_ws = TRUE))
demandc <- demandc[-c(28809:28812),] #day 29.10.2017 duplicate on 02:00
summary(demandc)
demandc$Datum <- as.Date(demandc$Datum, "%d.%m.%Y")  
demandc$date <- as.POSIXct(paste(demandc$Datum, demandc$Uhrzeit), format="%Y-%m-%d %H:%M:%S", tz='utc')
demandc <- demandc %>% select(date, everything())
demandc <- demandc[,-c(2,3)]
ddc <- create_series('2017-01-02' ~ '2018-09-30', '15 min')
dsmardc1 <- merge(ddc, demandc, by="date", all.x=T)
colnames(dsmardc1)[2] <- 'demand'
rm(demandc)
dsmardc2 <- xts(dsmardc1$demand,
               as.POSIXct(dsmardc1$date))
ends <- endpoints(dsmardc2,'hours',1) 
dsmardc2 <- period.apply(dsmardc2,ends,sum)
colnames(dsmardc2)[1] <- 'demand'

ddhc <- create_series('2017-01-02' ~ '2018-09-30', '1 hour')
dsmardc3 <- data.frame(ddhc)
dsmardc3$demand <- dsmardc2$demand
rm(dsmardc1, dsmardc2, ends)


## Data from SMARD- accesed on 11.06.2020 realisierte Stromerzeugung (RE)
## https://www.smard.de/home/wiki-article/446/636
## Photovoltaik 7976 wa (-)  but it is zero
rsmard <- data.frame(read_delim("Realisierte_Erzeugung_201701020000_201809302345.csv", ";", escape_double = FALSE, 
                                locale = locale(decimal_mark = ","), 
                                trim_ws = TRUE))
rsmard <- rsmard[-c(28809:28812),] #day 29.10.2017 duplicate on 02:00
rsmard$Datum <- as.Date(rsmard$Datum, "%d.%m.%Y")  
rsmard$date <- as.POSIXct(paste(rsmard$Datum, rsmard$Uhrzeit), format="%Y-%m-%d %H:%M:%S", tz='utc')
rsmard <- rsmard %>% select(date, everything()) 
rsmard <- rsmard[,-c(2,3)]
rsmardc <- merge(ddc, rsmard, by="date", all.x=T)
rsmardc$total <- rowSums(rsmardc[, 2:13])
rsmardc1 <- xts(rsmardc[,-1], order.by=as.POSIXct(rsmardc$date))
ends <- endpoints(rsmardc1,'hours',1) 
rsmardc2 <- period.apply(rsmardc1,ends,colSums)
rsmardc2 <- as.data.frame(rsmardc2)
rownames(rsmardc2) <- 1:nrow(rsmardc2) 

rm(ddc,rsmardc, ddhc,rsmardc1, ends)

Resdm5 <- cbind.data.frame(dsmardc3, rsmardc2)

#reducing must run by a factor
#Resdm5$factor <- Resdm5$demand / Resdm5$total
#must run
Resdm5$must <- rowSums(Resdm5[, c(3:10)])
#Resdm5$mustf <- Resdm5$must * Resdm5$factor
#residual demand
Resdm5$rd <- Resdm5$demand  - Resdm5$must
#renewables 
Resdm5$ren <- Resdm5$Wind.Offshore.MWh. + Resdm5$Wind.Onshore.MWh. + Resdm5$Photovoltaik.MWh.

time <- c(1:nrow(Resdm5))
rd1 <- cbind.data.frame(Resdm5$rd, time)
colnames(rd1) <- c( "rd", 'time')

datm7 <- merge(datm6, rd1, by="time")

setwd("C:\\Users\\...\\Replication\\R_paneldata") 
#adding fuel prices and electricity prices
h <- data.frame(read_excel("inst.xlsx"))
datm8 <- merge(datm7, h, by="time")
rm(datm6, datm7, rd1, dsmardc3, rsmardc2, h)

#write_xlsx(Resdm5, "resdm5.xlsx")

#adding probabilities chp---------------------------------------------------------
prob2 <- data.frame(read_excel("chp.xlsx", sheet="probchp"))
prob2 <- prob2[,-c(1)]

pr <- namemc[-c(1:3),-c(1:2)]
pr[c(2:15289), c(1:140)] <- 1

cchp <- which( pr[1,] == "53") #coal index
gchp <- which( pr[1,] == "55") #gas index         

prt <- data.frame(first3r[c(1),-c(1:2)])
pr <- pr[-c(1),]
pr[,cchp] <- prob2$coalchp
pr[,gchp] <- prob2$gaschp

pr <- rbind.data.frame(prt, pr)

pr$gaschp <- 1

pr1 <- pr[,pr[1,]==6]
pr2 <- pr[,pr[1,]==9]
pr3 <- pr[,pr[1,]==10]
Huckingen <- pr[,pr[1,]==13]
pr5 <- pr[,pr[1,]==14]
pr6 <- pr[,pr[1,]==15]
Walheim <- pr[,pr[1,]==16]
rest <- pr[c(131:140)] 
gaschp <- pr[c(141)]

prm1 <- cbind( pr1, pr2, Huckingen, pr3, pr5, pr6, Walheim, rest, gaschp)
prm1 <- prm1[-c(1),] 

rm(pr1,pr2, pr3, pr5, pr6, rest, Huckingen, Walheim, gaschp, cchp, gchp)
prm2 <- stack(prm1)
rm(prm1)
prm3 <- prm2[, c(2,1)]
##combining the indexes plant name and time
time <- rep(c(1:15288),85)
prm4 <- cbind.data.frame(prm3, time)
prm4$ix <- with(prm4, paste(ind, time))
prm4 <- prm4[,-c(1,3)]
rm(prm2,prm3)

##renaming
colnames(prm4) <- c( "probchp", "ix")
##adding tech matching to ix
datm9 <- merge(datm8, prm4, by="ix")
rm(pr, prm4, prt, rsmard, prob2, datm8)

#--------------------------------------------------------------------------------------------
#adding hourly wind data
wind <- data.frame(read_excel("wind.xlsx"))
wind2<- wind[-c(2),-c(1:2)]

wind3 <- wind2[,wind2[1,]==6]
wind4 <- wind2[,wind2[1,]==9]
wind5 <- wind2[,wind2[1,]==10]
Huckingen <- wind2[,wind2[1,]==13]
wind6 <- wind2[,wind2[1,]==14]
wind7 <- wind2[,wind2[1,]==15]
Walheim <- wind2[,wind2[1,]==16]
rest <- wind2[c(119:128)] 
gaschp <- wind2[c(129)]

windm1 <- cbind( wind3, wind4, wind5, Huckingen,wind6, wind7,Walheim, rest, gaschp)
windm1 <- windm1[-c(1),] 

windm2<- data.frame(stack(windm1))
windm3 <- cbind.data.frame(windm2,time)
windm3$ix <- with(windm3, paste(ind, time))
windm3 <- windm3[,-c(2,3)]

##renaming
colnames(windm3) <- c( "wind", "ix")
##adding tech matching to ix
datm10 <- merge(datm9, windm3, by="ix")
rm(wind2, wind3, wind4, wind5, wind6,wind7,wind, windm1, windm2, windm3, rest, gaschp, Huckingen,Walheim, datm9)


#--------------------------------------------------------------------------------------------
#adding solar
solar <- data.frame(read_excel("solar.xlsx"))
solar2<- solar[-c(2),-c(1:2)]

solar3 <- solar2[,solar2[1,]==6]
solar4 <- solar2[,solar2[1,]==9]
solar5 <- solar2[,solar2[1,]==10]
Huckingen <- solar2[,solar2[1,]==13]
solar6 <- solar2[,solar2[1,]==14]
solar7 <- solar2[,solar2[1,]==15]
Walheim <- solar2[,solar2[1,]==16]
rest <- solar2[c(119:128)] 
gaschp <- solar2[c(129)]

solarm1 <- cbind( solar3, solar4, solar5, Huckingen,solar6, solar7,Walheim, rest, gaschp)
solarm1 <- solarm1[-c(1),] 

solarm2<- data.frame(stack(solarm1))
solarm3 <- cbind.data.frame(solarm2,time)
solarm3$ix <- with(solarm3, paste(ind, time))
solarm3 <- solarm3[,-c(2,3)]

##renaming
colnames(solarm3) <- c( "solar", "ix")
##adding tech matching to ix
datm11 <- merge(datm10, solarm3, by="ix")
rm(solar2, solar3, solar4, solar5, solar6,solar7,solar, solarm1, solarm2, solarm3, rest, gaschp, Huckingen,Walheim, datm10)


###################################################################################################
#NO RAMPING CASE----------------------------------------------------------------------------------
#Table 3 data for regression (1)

datm11$tc <- datm11$fcost + datm11$ghgc 

#cleaning empty rd times
sfe1 <- with(datm11, subset(datm11,  !is.na(rd)))
#sfe1 <- na.omit(datm11)
summary(sfe1)
colnames(sfe1)[1]<- "plant"

library(plyr)
a <- ddply(sfe1,.(time,rd),nrow) #verifying that each time has 87 plants
#aqui me quede, cambiando el tiempo para que corra el algoritmo primero ordenando
sfe2 <- sfe1
sfe2$id <- sub("\\s+[^ ]+$", '', sfe1$plant)

sfe2 <- sfe2 %>% arrange(id, time)
#detach(package:plyr)
real_time <- data.frame(sfe2$time)

time2 <- rep(c(1:13862),85)
sfe2$time <- time2

rm(sfe1, time2)
#save(sfe2, file="sfe2.RData")
#load("sfe2.RData")
#--------------------------------------------------------------------------------------------

##Drawing the merit order curve and intersecting graphically on one point---------------------- 
ZZ <- data.frame(sfe2[which(sfe2["time"] == 8227),])
WW <- data.frame(ZZ[order(ZZ$tc),])
YY <- WW %>% mutate(cumsum = cumsum(cap))
##cleaning the environment
rm(ZZ,WW)
#extracting the rd as one value to draw a vertical and horizontal line, we already have this one
#from the original dataset
e <- sfe2[sfe2[,"time"] ==8227,8] #residual demand
p <- sfe2[sfe2[,"time"] ==8227,10] # price

ggplot() +
  geom_line(data=YY, aes(x=cumsum,y=tc, color="Tc")) + 
  geom_line(data=YY, aes(x=cumsum,y=ghgc, color="ETS"))+ 
  geom_vline(xintercept=e, color="black",linetype="dashed") +
  geom_hline(yintercept=p, color="azure4", linetype="dotted") +
  scale_color_manual("", breaks= c("Tc","ETS"), values=c("Tc"="blue", "ETS"="red"))+
  labs(y='\u20ac/MW', x = "MW") +
  scale_x_continuous(breaks = seq(-10000, 90000, 20000), lim = c(-10000, 90000)) +
  scale_y_continuous(breaks = seq(-100,170, 20), lim = c(-100, 170)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "azure4"), 
        axis.text = element_text(size = (7)), axis.title = element_text(size = (6)), 
        legend.text = element_text(size = (5.5)), legend.position = c(0.8,0.8), 
        legend.key = element_blank()) 



R = 50
Obs = 13862
stamp = c(1:Obs)

#seeds
a = 301  
b = a+R

#--------------------------------------------------------------------------------------------
p0 <- proc.time()[3] #5hours
set.seed(a:b) # R times
lista <- list()
for(k in 1:R){
  prb <- rbinom(length(sfe2$time), 1, prob = sfe2[[5]])
  dat <- sfe2 %>% mutate( capp = as.numeric(sfe2$cap)*prb )
  
  prb2 <- rbinom(length(sfe2$time), 1, prob = sfe2[[18]]) # after the change to resdemand
  datv <- dat %>% mutate( capp2 = as.numeric(dat$capp)*prb2 )
  
  datalist = list()
  for(i in 1:Obs){
    if (nrow(datv)==0) g
    ##check this to reduce time of loop
    ZZ <- data.frame(datv[which(datv["time"] == i ),])
    WW <- data.frame(ZZ[order(ZZ$tc),])
    YY <- WW %>% mutate(cumsum = cumsum(capp2))
    cross <-YY[which.min(abs(YY$rd-YY$cumsum)),]
    cross$i <- i
    datalist[[i]] <- cross
  }
  bd = do.call(rbind, datalist)
  
  lista[[k]] <- bd
}
print(proc.time()[3]-p0)

rm(cross, datalist, WW, YY, ZZ,i,p0, k, prb,a,b)

save(lista, file="uno.RData")
#--------------------------------------------------------------------------------------------
setwd("C:\\Users\\...\\R_paneldata\\SFE") 
load("uno.RData")


#--------------------------------------------------------------------------------------------
#Gathering the averages and constructing the panel data

R = 50
Obs = 13862
stamp = c(1:Obs)
#fcosts
suma1 = list()
for(n in 1:R){  
  suma1[[n]] <- lista[[n]]["fcost"]
}
d1 = do.call(cbind, suma1)
sum1 <- data.frame(stamp, fcost =rowMeans(d1), sdvfc = apply(d1,1,sd))

#coa cost
suma2 = list()
for(n in 1:R){  
  suma2[[n]] <- lista[[n]][c("ghgc")]
}
d2 = do.call(cbind, suma2)
sum2 <- data.frame(stamp, ghgc =rowMeans(d2), sdvghg = apply(d2,1,sd))


#total marginal costs
suma = list()
for(n in 1:R){  
  suma[[n]] <- lista[[n]]["tc"]
}
d = do.call(cbind, suma) 
sum3 <- data.frame(stamp, mumc =rowMeans(d), sdvmc = apply(d,1,sd))


#wind average
suma3 = list()
for(n in 1:R){  
  suma3[[n]] <- lista[[n]]["wind"]
}
d3 = do.call(cbind, suma3) 
sum4 <- data.frame(stamp, muwind =rowMeans(d3), sdvwind = apply(d3,1,sd))


#solar average
suma4 = list()
for(n in 1:R){  
  suma4[[n]] <- lista[[n]]["solar"]
}
d4 = do.call(cbind, suma4) 
sum5 <- data.frame(stamp, musolar =rowMeans(d4), sdvsolar = apply(d4,1,sd))


rd <- lista[[1]]["rd"]

price <- lista[[1]]["price"]

coal <- lista[[1]]["coal"]
gas <- lista[[1]]["gas"]
oil <- lista[[1]]["oil"]
coa <- lista[[1]]["coa"]


hour <- lista[[1]]["hour"]


colnames(real_time) <- "time"
real_time <- real_time %>% distinct()

uno <- cbind.data.frame(real_time, sum1, sum2[,-c(1)], sum3[,-c(1)], sum4[,-c(1)], sum5[,-c(1)], rd, price,coal, gas, oil, coa, hour)
uno <- uno[,-c(2)]

rm(d,d1,d2, rd, price, hour, sum1, sum2, sum3, suma1, suma2, suma, n, Obs, R, stamp)


stamp <- namemc1[,c(1:2)]
dayc <- rep(c("Mo", "Tu", "W", "Th", "Fr", "Sa", "Su"),each =24)
day <- rep(c(dayc), 91)
ja <- cbind.data.frame(stamp,day)

attach(ja)
ja$week[day=="Mo" | day=="Tu" | day=="W" | day=="Th" | day=="Fr" ] <- "work"
ja$week[day=="Sa" | day=="Su" ] <- "end"
detach(ja)

aa <- join( real_time, ja, by = "time")
aa$month <- as.numeric(substring(aa$Date,6,7))
aa$year <- as.numeric(substring(aa$Date,1,4))


colnames(uno)[1] <- "time"

sfe_one <- join( uno, aa, by = "time")

attach(sfe_one)
sfe_one$block[6<=hour & hour<=9] <- "peak1"
sfe_one$block[13<=hour & hour<=16] <- "peak2"
sfe_one$block[20<=hour & hour<=21] <- "peak3"
sfe_one$block[10<=hour & hour<=12] <- "sppeak1"
sfe_one$block[17<=hour & hour<=19] <- "sppeak2"
sfe_one$block[1<=hour & hour<=5] <- "off"
sfe_one$block[22<=hour & hour<=24] <- "off"
detach(sfe_one)


attach(sfe_one)
sfe_one$period[4<=month & month<=9] <- "Summer"
sfe_one$period[1<=month & month<=3] <- "Winter"
sfe_one$period[10<=month & month<=12] <- "Winter"
detach(sfe_one)


rm(a, aa, coa, coal, gas, oil, sfe1, uno)

write_xlsx(sfe_one, "sfe_one.xlsx")

#HISTOGRAMS MC-------------------------------------------------------
#histogram
ggplot(data=sfe_one, aes(mumc)) +
  geom_histogram(binwidth=0.5) +
  scale_x_continuous(breaks = seq(0, 140, 30), lim = c(0, 140)) +
  scale_y_continuous(breaks = seq(0, 700, 200), lim = c(0, 700))




###################################################################################################
#RAMPING CASE----------------------------------------------------------------------------------
#Table 3 data for regression (2)

##ramping costs
b <- data.frame(read_excel("ramp.xlsx"))

##extracting ff columns
b1 <- b[,b[1,]==6]
b2 <- b[,b[1,]==9]
b3 <- b[,b[1,]==10]
Huckingen <- b[,b[1,]==13]
b5 <- b[,b[1,]==14]
b6 <- b[,b[1,]==15]
Walheim <- b[,b[1,]==16]
rest <- b[c(121:130)] 
gaschp <- b[c(131)] 

bm1 <- cbind.data.frame(b1, b2, Huckingen, b3, b5, b6, Walheim, rest,gaschp)
bm1 <- bm1[-c(1,2),]
rm(b, b1,b2, b3, b5, b6, rest, Huckingen, Walheim, gaschp)
##transpose
bm2 <- data.frame(stack(bm1))
bm3 <- cbind.data.frame(bm2,time)
bm3$ix <- with(bm3, paste(ind, time))
bm3 <- bm3[,-c(2,3)]

##renaming
colnames(bm3) <- c( "rampc", "ix")
##adding tech matching to ix
datm11r <- merge(datm11, bm3, by="ix")
rm(bm2, bm3, bm4, bm5, bm6,bm7,bm, bm1, bm2, bm3, rest, gaschp, Huckingen,Walheim, datm10)

##sumando el costo del combustible mas el costo del carbono
datm11r$tcr <- datm11r$fcost + datm11r$ghgc + datm11r$rampc


#cleaning empty rd times
sfe1r <- with(datm11r, subset(datm11r,  !is.na(rd)))
#sfe1 <- na.omit(datm11)
summary(sfe1r)
colnames(sfe1r)[1]<- "plant"

library(plyr)
ar <- ddply(sfe1r,.(time,rd),nrow) #verifying that each time has 87 plants
#aqui me quede, cambiando el tiempo para que corra el algoritmo primero ordenando
sfe2r <- sfe1r
sfe2r$id <- sub("\\s+[^ ]+$", '', sfe1r$plant)

sfe2r <- sfe2r %>% arrange(id, time)
#detach(package:plyr)
real_time <- data.frame(sfe2r$time)

time2 <- rep(c(1:13862),85)
sfe2r$time <- time2

rm(sfe1r, time2)

#save(sfe2r, file="sfe2r.RData")
#load("sfe2r.RData")


R = 50
Obs = 13862
stamp = c(1:Obs)

#seeds
a = 301  
b = a+R

#--------------------------------------------------------------------------------------------
p0 <- proc.time()[3] #5hours
set.seed(a:b) # R times
lista <- list()
for(k in 1:R){
  prb <- rbinom(length(sfe2r$time), 1, prob = sfe2r[[5]])
  dat <- sfe2r %>% mutate( capp = as.numeric(sfe2r$cap)*prb )
  
  prb2 <- rbinom(length(sfe2r$time), 1, prob = sfe2r[[18]]) # after the change to resdemand
  datv <- dat %>% mutate( capp2 = as.numeric(dat$capp)*prb2 )
  
  datalist = list()
  for(i in 1:Obs){
    if (nrow(datv)==0) g
    ##check this to reduce time of loop
    ZZ <- data.frame(datv[which(datv["time"] == i ),])
    WW <- data.frame(ZZ[order(ZZ$tcr),])
    YY <- WW %>% mutate(cumsum = cumsum(capp2))
    cross <-YY[which.min(abs(YY$rd-YY$cumsum)),]
    cross$i <- i
    datalist[[i]] <- cross
  }
  bd = do.call(rbind, datalist)
  
  lista[[k]] <- bd
}
print(proc.time()[3]-p0)

rm(cross, datalist, WW, YY, ZZ,i,p0, k, prb,a,b)

save(lista, file="dos.RData")
#--------------------------------------------------------------------------------------------
setwd("C:\\Users\\...\\Replication\\R_paneldata\\SFE") 
load("dos.RData")


#--------------------------------------------------------------------------------------------
#Gathering the averages and constructing the panel data

R = 50
Obs = 13862
stamp = c(1:Obs)
#fcosts
suma1 = list()
for(n in 1:R){  
  suma1[[n]] <- lista[[n]]["fcost"]
}
d1 = do.call(cbind, suma1)
sum1 <- data.frame(stamp, fcost =rowMeans(d1), sdvfc = apply(d1,1,sd))

#coa cost
suma2 = list()
for(n in 1:R){  
  suma2[[n]] <- lista[[n]][c("ghgc")]
}
d2 = do.call(cbind, suma2)
sum2 <- data.frame(stamp, ghgc =rowMeans(d2), sdvghg = apply(d2,1,sd))

#ramp cost
suma3 = list()
for(n in 1:R){  
  suma3[[n]] <- lista[[n]][c("rampc")]
}
d33 = do.call(cbind, suma3)
sum33 <- data.frame(stamp, rampc =rowMeans(d33), sdvramp = apply(d33,1,sd))


#total marginal costs
suma = list()
for(n in 1:R){  
  suma[[n]] <- lista[[n]]["tcr"]
}
d = do.call(cbind, suma) 
sum3 <- data.frame(stamp, mumc =rowMeans(d), sdvmc = apply(d,1,sd))


#wind average
suma3 = list()
for(n in 1:R){  
  suma3[[n]] <- lista[[n]]["wind"]
}
d3 = do.call(cbind, suma3) 
sum4 <- data.frame(stamp, muwind =rowMeans(d3), sdvwind = apply(d3,1,sd))


#solar average
suma4 = list()
for(n in 1:R){  
  suma4[[n]] <- lista[[n]]["solar"]
}
d4 = do.call(cbind, suma4) 
sum5 <- data.frame(stamp, musolar =rowMeans(d4), sdvsolar = apply(d4,1,sd))


rd <- lista[[1]]["rd"]

price <- lista[[1]]["price"]

coal <- lista[[1]]["coal"]
gas <- lista[[1]]["gas"]
oil <- lista[[1]]["oil"]
coa <- lista[[1]]["coa"]


hour <- lista[[1]]["hour"]


colnames(real_time) <- "time"
real_time <- real_time %>% distinct()

dos <- cbind.data.frame(real_time, sum1, sum2[,-c(1)], sum33[,-c(1)], sum3[,-c(1)], sum4[,-c(1)], sum5[,-c(1)], rd, price,coal, gas, oil, coa, hour)
dos <- dos[,-c(2)]

rm(d,d1,d2, rd, price, hour, sum1, sum2, sum33, sum3, suma1, suma2, suma, n, Obs, R, stamp)


stamp <- namemc1[,c(1:2)]
dayc <- rep(c("Mo", "Tu", "W", "Th", "Fr", "Sa", "Su"),each =24)
day <- rep(c(dayc), 91)
ja <- cbind.data.frame(stamp,day)
attach(ja)
ja$week[day=="Mo" | day=="Tu" | day=="W" | day=="Th" | day=="Fr" ] <- "work"
ja$week[day=="Sa" | day=="Su" ] <- "end"
detach(ja)
aa <- join( real_time, ja, by = "time")
aa$month <- as.numeric(substring(aa$Date,6,7))
aa$year <- as.numeric(substring(aa$Date,1,4))

colnames(dos)[1] <- "time"

sfe_two <- join( dos, aa, by = "time")

attach(sfe_two)
sfe_two$block[6<=hour & hour<=9] <- "peak1"
sfe_two$block[13<=hour & hour<=16] <- "peak2"
sfe_two$block[20<=hour & hour<=21] <- "peak3"
sfe_two$block[10<=hour & hour<=12] <- "sppeak1"
sfe_two$block[17<=hour & hour<=19] <- "sppeak2"
sfe_two$block[1<=hour & hour<=5] <- "off"
sfe_two$block[22<=hour & hour<=24] <- "off"
detach(sfe_two)


attach(sfe_two)
sfe_two$period[4<=month & month<=9] <- "Summer"
sfe_two$period[1<=month & month<=3] <- "Winter"
sfe_two$period[10<=month & month<=12] <- "Winter"
detach(sfe_two)



rm(a, aa, coa, coal, gas, oil, sfe1, dos)

write_xlsx(sfe_two, "sfe_two.xlsx")

#HISTOGRAMS MC-------------------------------------------------------
#histogram
ggplot(data=sfe_two, aes(mumc)) +
  geom_histogram(binwidth=0.5) +
  scale_x_continuous(breaks = seq(0, 140, 30), lim = c(0, 140)) +
  scale_y_continuous(breaks = seq(0, 700, 200), lim = c(0, 700))



###################################################################################################
#FORECAST CASE----------------------------------------------------------------------------------
#Table 3 data for regression (3)

#forecast demand
setwd("C:\\Users\\...\\Replication\\R_paneldata") 
demandf <- data.frame(read_delim("PS1718.csv", ";", escape_double = FALSE, 
                                 locale = locale(decimal_mark = ","), 
                                 trim_ws = TRUE))
demandf <- demandf[-c(28901:28904),] #day 29.10.2017 duplicate on 02:00
demandf$Datum <- as.Date(demandf$Datum, "%d.%m.%Y")  
demandf$date <- as.POSIXct(paste(demandf$Datum, demandf$Uhrzeit), format="%Y-%m-%d %H:%M:%S", tz='utc')
demandf <- demandf %>% select(date, everything())
demandf <- demandf[,-c(2,3)]
ddc <- create_series('2017-01-02' ~ '2018-09-30', '15 min')
dsmardc1f <- merge(demandf,ddc, by.y="date", all.y=T)
colnames(dsmardc1f)[2] <- 'demand'
dsmardc1f$xx <- demandf$Gesamt.MWh.-dsmardc1f$demand
dsmardc1f$demand1 <- dsmardc1f$demand + dsmardc1f$xx
dsmardc1f <- dsmardc1f[,-c(2:3)]
dsmardc2f <- xts(dsmardc1f$demand,
                as.POSIXct(dsmardc1f$date))
ends <- endpoints(dsmardc2f,'hours',1) 
dsmardc2f <- period.apply(dsmardc2f,ends,sum)
colnames(dsmardc2f)[1] <- 'demandf'

ddhc <- create_series('2017-01-02' ~ '2018-09-30', '1 hour')
dsmardc3f <- data.frame(ddhc)
dsmardc3f$demandf <- dsmardc2f$demandf
rm(demandf, ddc, dsmardc1f, dsmardc2f)


#forecast renewables
rsmardf <- data.frame(read_delim("PE1718.csv", ";", escape_double = FALSE, 
                                locale = locale(decimal_mark = ","), 
                                trim_ws = TRUE))
rsmardf <- rsmardf[-c(28901:28904),] #day 29.10.2017 duplicate on 02:00
rsmardf$Datum <- as.Date(rsmardf$Datum, "%d.%m.%Y")  
rsmardf$date <- as.POSIXct(paste(rsmardf$Datum, rsmardf$Uhrzeit), format="%Y-%m-%d %H:%M:%S", tz='utc')
rsmardf <- rsmardf %>% select(date, everything()) 
rsmardf <- rsmardf[,-c(2,3,4,8)]
rsmardf$renf <- rsmardf$Wind.Offshore.MWh. + rsmardf$Wind.Onshore.MWh. + rsmardf$Photovoltaik.MWh. 
rsmardf <- rsmardf[,-c(2:4)]
ddc <- create_series('2017-01-02' ~ '2018-09-30', '15 min')
rsmardfc <- merge(rsmardf, ddc, by.y="date", all.y=T)
rsmardfc$xx <- rsmardf$renf-rsmardfc$renf
rsmardfc$renf1 <- rsmardfc$renf + rsmardfc$xx
rsmardfc <- rsmardfc[,-c(2:3)]
rsmardfc1 <- xts(rsmardfc[,-1], order.by=as.POSIXct(rsmardfc$date))
ends <- endpoints(rsmardfc1,'hours',1) 
rsmardfc2 <- period.apply(rsmardfc1,ends,colSums)
colnames(rsmardfc2)[1] <- 'renf'

ddhc <- create_series('2017-01-02' ~ '2018-09-30', '1 hour')
rsmardfc3 <- data.frame(ddhc)
rsmardfc3$renf <- rsmardfc2$renf

rm(ddc,rsmardf, rsmardfc, ddhc,rsmardfc1,rsmardfc2,ends, rsmard, ends)

Resdm5f <- cbind.data.frame(Resdm5, dsmardc3f, rsmardfc3)
Resdm5f <- Resdm5f[,-c(19,21)]

#must run
Resdm5f$mustf <- rowSums(Resdm5f[, c(3,4,8,9,10,20)])
#Resdm5$mustf <- Resdm5$must * Resdm5$factor
#residual demand
Resdm5f$rdf <- Resdm5f$demandf  - Resdm5f$mustf

time <- c(1:nrow(Resdm5f))
rd1f <- cbind.data.frame(Resdm5f$rdf, time)
colnames(rd1f) <- c( "rdf", 'time')

datm11f <- merge(datm11, rd1f, by="time")

datm11f$tc <- datm11f$fcost + datm11f$ghgc 

#cleaning empty rd times
sfe1f <- with(datm11f, subset(datm11f,  !is.na(rdf)))
#sfe1 <- na.omit(datm11f)
summary(sfe1f)


library(plyr)
a <- ddply(sfe1f,.(time,rdf),nrow) #verifying that each time has 87 plants
#aqui me quede, cambiando el tiempo para que corra el algoritmo primero ordenando
sfe2f <- sfe1f
sfe2f$id <- sub("\\s+[^ ]+$", '', sfe1f$ix)

sfe2f <- sfe2f %>% arrange(id, time)
#detach(package:plyr)
real_time <- data.frame(sfe2f$time)

time2f <- rep(c(1:13315),85)
sfe2f$time <- time2f

rm(sfe1f, time2f)

#save(sfe2f, file="sfe2f.RData")
#load("sfe2f.RData")

rm(a, dsmardc3f, rd1f, real_time, rsmardfc3)


R = 50
Obs = 13315
stamp = c(1:Obs)

#seeds
a = 301  
b = a+R

#--------------------------------------------------------------------------------------------
p0 <- proc.time()[3] #5hours
set.seed(a:b) # R times
lista <- list()
for(k in 1:R){
  prb <- rbinom(length(sfe2f$time), 1, prob = sfe2f[[5]])
  dat <- sfe2f %>% mutate( capp = as.numeric(sfe2f$cap)*prb )
  
  prb2 <- rbinom(length(sfe2f$time), 1, prob = sfe2f[[18]]) # after the change to resdemand
  datv <- dat %>% mutate( capp2 = as.numeric(dat$capp)*prb2 )
  
  datalist = list()
  for(i in 1:Obs){
    if (nrow(datv)==0) g
    ##check this to reduce time of loop
    ZZ <- data.frame(datv[which(datv["time"] == i ),])
    WW <- data.frame(ZZ[order(ZZ$tc),])
    YY <- WW %>% mutate(cumsum = cumsum(capp2))
    cross <-YY[which.min(abs(YY$rdf-YY$cumsum)),]
    cross$i <- i
    datalist[[i]] <- cross
  }
  bd = do.call(rbind, datalist)
  
  lista[[k]] <- bd
}
print(proc.time()[3]-p0)

rm(cross, datalist, WW, YY, ZZ,i,p0, k, prb,a,b)

save(lista, file="tres.RData")
#--------------------------------------------------------------------------------------------
setwd("C:\\Users\\...\\Replication\\R_paneldata\\SFE") 
load("tres.RData")


#--------------------------------------------------------------------------------------------
#Gathering the averages and constructing the panel data

R = 50
Obs = 13315
stamp = c(1:Obs)
#fcosts
suma1 = list()
for(n in 1:R){  
  suma1[[n]] <- lista[[n]]["fcost"]
}
d1 = do.call(cbind, suma1)
sum1 <- data.frame(stamp, fcost =rowMeans(d1), sdvfc = apply(d1,1,sd))

#coa cost
suma2 = list()
for(n in 1:R){  
  suma2[[n]] <- lista[[n]][c("ghgc")]
}
d2 = do.call(cbind, suma2)
sum2 <- data.frame(stamp, ghgc =rowMeans(d2), sdvghg = apply(d2,1,sd))


#total marginal costs
suma = list()
for(n in 1:R){  
  suma[[n]] <- lista[[n]]["tc"]
}
d = do.call(cbind, suma) 
sum3 <- data.frame(stamp, mumc =rowMeans(d), sdvmc = apply(d,1,sd))


#wind average
suma3 = list()
for(n in 1:R){  
  suma3[[n]] <- lista[[n]]["wind"]
}
d3 = do.call(cbind, suma3) 
sum4 <- data.frame(stamp, muwind =rowMeans(d3), sdvwind = apply(d3,1,sd))


#solar average
suma4 = list()
for(n in 1:R){  
  suma4[[n]] <- lista[[n]]["solar"]
}
d4 = do.call(cbind, suma4) 
sum5 <- data.frame(stamp, musolar =rowMeans(d4), sdvsolar = apply(d4,1,sd))


rdf <- lista[[1]]["rdf"]

pricef <- lista[[1]]["pricef"]


coal <- lista[[1]]["coal"]
gas <- lista[[1]]["gas"]
oil <- lista[[1]]["oil"]
coa <- lista[[1]]["coa"]


hour <- lista[[1]]["hour"]


colnames(real_time) <- "time"
real_time <- real_time %>% distinct()

tres <- cbind.data.frame(real_time, sum1, sum2[,-c(1)], sum3[,-c(1)], sum4[,-c(1)], sum5[,-c(1)], rdf, pricef,coal, gas, oil, coa, hour)
tres <- tres[,-c(2)]

rm(d,d1,d2, rdf, pricef, hour, sum1, sum2, sum3, suma1, suma2, suma, n, Obs, R, stamp)


stamp <- namemc1[,c(1:2)]
dayc <- rep(c("Mo", "Tu", "W", "Th", "Fr", "Sa", "Su"),each =24)
day <- rep(c(dayc), 91)
ja <- cbind.data.frame(stamp,day)

attach(ja)
ja$week[day=="Mo" | day=="Tu" | day=="W" | day=="Th" | day=="Fr" ] <- "work"
ja$week[day=="Sa" | day=="Su" ] <- "end"
detach(ja)

aa <- join( real_time, ja, by = "time")
aa$month <- as.numeric(substring(aa$Date,6,7))
aa$year <- as.numeric(substring(aa$Date,1,4))

colnames(tres)[1] <- "time"

sfe_three <- join( tres, aa, by = "time")

attach(sfe_three)
sfe_three$block[6<=hour & hour<=9] <- "peak1"
sfe_three$block[13<=hour & hour<=16] <- "peak2"
sfe_three$block[20<=hour & hour<=21] <- "peak3"
sfe_three$block[10<=hour & hour<=12] <- "sppeak1"
sfe_three$block[17<=hour & hour<=19] <- "sppeak2"
sfe_three$block[1<=hour & hour<=5] <- "off"
sfe_three$block[22<=hour & hour<=24] <- "off"
detach(sfe_three)


attach(sfe_three)
sfe_three$period[4<=month & month<=9] <- "Summer"
sfe_three$period[1<=month & month<=3] <- "Winter"
sfe_three$period[10<=month & month<=12] <- "Winter"
detach(sfe_three)


rm(a, aa, coa, coal, gas, oil, sfe1, dos)

write_xlsx(sfe_three, "sfe_three.xlsx")

#HISTOGRAMS MC-------------------------------------------------------
#histogram
ggplot(data=sfe_three, aes(mumc)) +
  geom_histogram(binwidth=0.5) +
  scale_x_continuous(breaks = seq(0, 140, 30), lim = c(0, 140)) +
  scale_y_continuous(breaks = seq(0, 700, 200), lim = c(0, 700))


#############################################################################################
#MC CALCULATION - END PROCESS
#############################################################################################


